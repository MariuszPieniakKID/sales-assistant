const express = require('express');
const session = require('express-session');
const bcrypt = require('bcryptjs');
const path = require('path');
const multer = require('multer');
const fs = require('fs');
require('dotenv').config();

// Importuj konfiguracjƒô Neon
const pool = require('./neon-config');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));

// Konfiguracja sesji
app.use(session({
  secret: process.env.SESSION_SECRET || 'your-secret-key',
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: false, // set to true if using HTTPS
    maxAge: 24 * 60 * 60 * 1000 // 24 godziny
  }
}));

// Konfiguracja multer dla upload√≥w
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadPath = 'uploads/';
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});
const upload = multer({ storage: storage });

// Funkcja do testowania po≈ÇƒÖczenia z bazƒÖ danych Neon
async function testNeonConnection() {
  console.log('üîå Testowanie po≈ÇƒÖczenia z bazƒÖ danych Neon...');
  
  try {
    const client = await pool.connect();
    console.log('‚úÖ Po≈ÇƒÖczenie z bazƒÖ danych Neon udane!');
    
    // Sprawd≈∫ czy tabele istniejƒÖ
    const result = await client.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
    `);
    console.log('üìä Dostƒôpne tabele:', result.rows.map(r => r.table_name));
    
    client.release();
    return true;
  } catch (err) {
    console.error('‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z bazƒÖ danych Neon:', err.message);
    console.error('üîç Szczeg√≥≈Çy b≈Çƒôdu:', err);
    return false;
  }
}

// Middleware sprawdzajƒÖcy uwierzytelnienie
function requireAuth(req, res, next) {
  if (req.session && req.session.userId) {
    next();
  } else {
    res.redirect('/login');
  }
}

// Middleware sprawdzajƒÖcy uprawnienia admina
function requireAdmin(req, res, next) {
  if (req.session && req.session.userId && req.session.userId === 3) { // User ID 3 to admin
    next();
  } else {
    res.status(403).json({ success: false, message: 'Brak uprawnie≈Ñ administratora' });
  }
}

// Routes

// Strona logowania
app.get('/', (req, res) => {
  if (req.session && req.session.userId) {
    res.redirect('/dashboard');
  } else {
    res.sendFile(path.join(__dirname, 'public', 'login.html'));
  }
});

app.get('/login', (req, res) => {
  if (req.session && req.session.userId) {
    res.redirect('/dashboard');
  } else {
    res.sendFile(path.join(__dirname, 'public', 'login.html'));
  }
});

// Endpoint logowania
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  
  console.log('üîë Pr√≥ba logowania dla email:', email);
  console.log('üìù Otrzymane dane:', { email, hasPassword: !!password });
  
  try {
    console.log('üîó ≈ÅƒÖczenie z bazƒÖ danych...');
    const client = await pool.connect();
    
    console.log('üîç Szukanie u≈ºytkownika w bazie...');
    const result = await client.query('SELECT * FROM users WHERE email = $1', [email]);
    
    console.log('üìä Wynik zapytania:', {
      found: result.rows.length > 0,
      userCount: result.rows.length
    });
    
    if (result.rows.length === 0) {
      console.log('‚ùå U≈ºytkownik nie znaleziony w bazie');
      await client.release();
      return res.status(401).json({ success: false, message: 'Nieprawid≈Çowy email lub has≈Ço' });
    }
    
    const user = result.rows[0];
    console.log('üë§ Znaleziony u≈ºytkownik:', {
      id: user.id,
      email: user.email,
      firstName: user.first_name,
      hasPasswordHash: !!user.password_hash
    });
    
    console.log('üîê Sprawdzanie has≈Ça...');
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    console.log('üîë Wynik sprawdzenia has≈Ça:', isValidPassword);
    
    if (!isValidPassword) {
      console.log('‚ùå Nieprawid≈Çowe has≈Ço');
      await client.release();
      return res.status(401).json({ success: false, message: 'Nieprawid≈Çowy email lub has≈Ço' });
    }
    
    console.log('‚úÖ Logowanie udane, tworzenie sesji...');
    req.session.userId = user.id;
    req.session.userFirstName = user.first_name;
    req.session.userLastName = user.last_name;
    
    await client.release();
    console.log('üéâ Sesja utworzona pomy≈õlnie');
    res.json({ success: true, message: 'Zalogowano pomy≈õlnie' });
    
  } catch (err) {
    console.error('üí• B≈ÇƒÖd logowania:', err.message);
    console.error('üîç Pe≈Çny b≈ÇƒÖd:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera: ' + err.message });
  }
});

// Dashboard - g≈Ç√≥wna strona po zalogowaniu
app.get('/dashboard', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
});

// API do pobierania danych u≈ºytkownika
app.get('/api/user', requireAuth, (req, res) => {
  res.json({
    id: req.session.userId,
    firstName: req.session.userFirstName,
    lastName: req.session.userLastName
  });
});

// Wylogowanie
app.post('/api/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ success: false, message: 'B≈ÇƒÖd wylogowania' });
    }
    res.clearCookie('connect.sid');
    res.json({ success: true, message: 'Wylogowano pomy≈õlnie' });
  });
});

// API dla produkt√≥w
app.get('/api/products', requireAuth, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(
      'SELECT * FROM products WHERE user_id = $1 ORDER BY created_at DESC',
      [req.session.userId]
    );
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania produkt√≥w:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

app.post('/api/products', requireAuth, upload.array('files'), async (req, res) => {
  const { name, description, comment } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Dodaj produkt
    const productResult = await client.query(
      'INSERT INTO products (user_id, name, description, comment) VALUES ($1, $2, $3, $4) RETURNING *',
      [req.session.userId, name, description, comment]
    );
    
    const productId = productResult.rows[0].id;
    
    // Dodaj pliki je≈õli zosta≈Çy przes≈Çane
    if (req.files && req.files.length > 0) {
      for (const file of req.files) {
        await client.query(
          'INSERT INTO product_files (product_id, file_name, file_path, file_type) VALUES ($1, $2, $3, $4)',
          [productId, file.originalname, file.path, file.mimetype]
        );
      }
    }
    
    await client.release();
    res.json({ success: true, product: productResult.rows[0] });
    
  } catch (err) {
    console.error('B≈ÇƒÖd dodawania produktu:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Edycja produktu
app.put('/api/products/:id', requireAuth, upload.array('files'), async (req, res) => {
  const productId = req.params.id;
  const { name, description, comment } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Sprawd≈∫ czy produkt nale≈ºy do u≈ºytkownika
    const checkResult = await client.query(
      'SELECT * FROM products WHERE id = $1 AND user_id = $2',
      [productId, req.session.userId]
    );
    
    if (checkResult.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'Produkt nie znaleziony' });
    }
    
    // Aktualizuj produkt
    const updateResult = await client.query(
      'UPDATE products SET name = $1, description = $2, comment = $3 WHERE id = $4 AND user_id = $5 RETURNING *',
      [name, description, comment, productId, req.session.userId]
    );
    
    // Dodaj nowe pliki je≈õli zosta≈Çy przes≈Çane
    if (req.files && req.files.length > 0) {
      for (const file of req.files) {
        await client.query(
          'INSERT INTO product_files (product_id, file_name, file_path, file_type) VALUES ($1, $2, $3, $4)',
          [productId, file.originalname, file.path, file.mimetype]
        );
      }
    }
    
    await client.release();
    res.json({ success: true, product: updateResult.rows[0] });
    
  } catch (err) {
    console.error('B≈ÇƒÖd edycji produktu:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Usuwanie produktu
app.delete('/api/products/:id', requireAuth, async (req, res) => {
  const productId = req.params.id;
  
  try {
    const client = await pool.connect();
    
    // Sprawd≈∫ czy produkt nale≈ºy do u≈ºytkownika
    const checkResult = await client.query(
      'SELECT * FROM products WHERE id = $1 AND user_id = $2',
      [productId, req.session.userId]
    );
    
    if (checkResult.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'Produkt nie znaleziony' });
    }
    
    // Pobierz pliki do usuniƒôcia
    const filesResult = await client.query(
      'SELECT file_path FROM product_files WHERE product_id = $1',
      [productId]
    );
    
    // Usu≈Ñ pliki z dysku
    for (const fileRow of filesResult.rows) {
      try {
        if (fs.existsSync(fileRow.file_path)) {
          fs.unlinkSync(fileRow.file_path);
        }
      } catch (fileErr) {
        console.error('B≈ÇƒÖd usuwania pliku:', fileErr);
      }
    }
    
    // Usu≈Ñ produkt (CASCADE usunie te≈º pliki z bazy)
    await client.query(
      'DELETE FROM products WHERE id = $1 AND user_id = $2',
      [productId, req.session.userId]
    );
    
    await client.release();
    res.json({ success: true, message: 'Produkt usuniƒôty' });
    
  } catch (err) {
    console.error('B≈ÇƒÖd usuwania produktu:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// API dla klient√≥w
app.get('/api/clients', requireAuth, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query('SELECT * FROM clients ORDER BY name ASC');
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania klient√≥w:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

app.post('/api/clients', requireAuth, async (req, res) => {
  const { name, description, comment, ai_notes } = req.body;
  
  try {
    const client = await pool.connect();
    const result = await client.query(
      'INSERT INTO clients (name, description, comment, ai_notes) VALUES ($1, $2, $3, $4) RETURNING *',
      [name, description, comment, ai_notes]
    );
    await client.release();
    res.json({ success: true, client: result.rows[0] });
  } catch (err) {
    console.error('B≈ÇƒÖd dodawania klienta:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Edycja klienta
app.put('/api/clients/:id', requireAuth, async (req, res) => {
  const clientId = req.params.id;
  const { name, description, comment, ai_notes } = req.body;
  
  try {
    const client = await pool.connect();
    const result = await client.query(
      'UPDATE clients SET name = $1, description = $2, comment = $3, ai_notes = $4 WHERE id = $5 RETURNING *',
      [name, description, comment, ai_notes, clientId]
    );
    
    if (result.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'Klient nie znaleziony' });
    }
    
    await client.release();
    res.json({ success: true, client: result.rows[0] });
  } catch (err) {
    console.error('B≈ÇƒÖd edycji klienta:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Usuwanie klienta
app.delete('/api/clients/:id', requireAuth, async (req, res) => {
  const clientId = req.params.id;
  
  try {
    const client = await pool.connect();
    const result = await client.query('DELETE FROM clients WHERE id = $1', [clientId]);
    
    if (result.rowCount === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'Klient nie znaleziony' });
    }
    
    await client.release();
    res.json({ success: true, message: 'Klient usuniƒôty' });
  } catch (err) {
    console.error('B≈ÇƒÖd usuwania klienta:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// API dla spotka≈Ñ
app.get('/api/sales', requireAuth, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(`
      SELECT s.*, c.name as client_name, p.name as product_name 
      FROM sales s 
      JOIN clients c ON s.client_id = c.id 
      JOIN products p ON s.product_id = p.id 
      WHERE p.user_id = $1 
      ORDER BY s.meeting_datetime DESC
    `, [req.session.userId]);
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania spotka≈Ñ:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Aktualizacja notatek spotkania
app.put('/api/sales/:id/notes', requireAuth, async (req, res) => {
  const meetingId = req.params.id;
  const { notes } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Sprawd≈∫ czy spotkanie nale≈ºy do u≈ºytkownika (przez produkt)
    const checkResult = await client.query(`
      SELECT s.* FROM sales s 
      JOIN products p ON s.product_id = p.id 
      WHERE s.id = $1 AND p.user_id = $2
    `, [meetingId, req.session.userId]);
    
    if (checkResult.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'Spotkanie nie znalezione' });
    }
    
    // Aktualizuj notatki
    const result = await client.query(
      'UPDATE sales SET own_notes = $1 WHERE id = $2 RETURNING *',
      [notes, meetingId]
    );
    
    await client.release();
    res.json({ success: true, meeting: result.rows[0] });
    
  } catch (err) {
    console.error('B≈ÇƒÖd aktualizacji notatek:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// API dla profilu u≈ºytkownika
app.get('/api/profile', requireAuth, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(
      'SELECT id, first_name, last_name, email, phone, created_at FROM users WHERE id = $1',
      [req.session.userId]
    );
    
    if (result.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'U≈ºytkownik nie znaleziony' });
    }
    
    await client.release();
    res.json(result.rows[0]);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania profilu:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Aktualizacja profilu u≈ºytkownika
app.put('/api/profile', requireAuth, async (req, res) => {
  const { firstName, lastName, email, phone } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Sprawd≈∫ czy email nie jest u≈ºywany przez innego u≈ºytkownika
    if (email) {
      const emailCheck = await client.query(
        'SELECT id FROM users WHERE email = $1 AND id != $2',
        [email, req.session.userId]
      );
      
      if (emailCheck.rows.length > 0) {
        await client.release();
        return res.status(400).json({ success: false, message: 'Ten email jest ju≈º u≈ºywany' });
      }
    }
    
    // Aktualizuj profil
    const result = await client.query(`
      UPDATE users 
      SET first_name = $1, last_name = $2, email = $3, phone = $4 
      WHERE id = $5 
      RETURNING id, first_name, last_name, email, phone
    `, [firstName, lastName, email, phone, req.session.userId]);
    
    await client.release();
    res.json({ success: true, user: result.rows[0] });
  } catch (err) {
    console.error('B≈ÇƒÖd aktualizacji profilu:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Zmiana has≈Ça
app.post('/api/change-password', requireAuth, async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Pobierz obecne has≈Ço
    const userResult = await client.query(
      'SELECT password_hash FROM users WHERE id = $1',
      [req.session.userId]
    );
    
    if (userResult.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'U≈ºytkownik nie znaleziony' });
    }
    
    // Sprawd≈∫ obecne has≈Ço
    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, userResult.rows[0].password_hash);
    
    if (!isCurrentPasswordValid) {
      await client.release();
      return res.status(400).json({ success: false, message: 'Obecne has≈Ço jest nieprawid≈Çowe' });
    }
    
    // Zaszyfruj nowe has≈Ço
    const newPasswordHash = await bcrypt.hash(newPassword, 10);
    
    // Zaktualizuj has≈Ço
    await client.query(
      'UPDATE users SET password_hash = $1 WHERE id = $2',
      [newPasswordHash, req.session.userId]
    );
    
    await client.release();
    res.json({ success: true, message: 'Has≈Ço zosta≈Ço zmienione' });
  } catch (err) {
    console.error('B≈ÇƒÖd zmiany has≈Ça:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Statystyki u≈ºytkownika
app.get('/api/user-stats', requireAuth, async (req, res) => {
  try {
    const client = await pool.connect();
    
    // Policz produkty u≈ºytkownika
    const productsResult = await client.query(
      'SELECT COUNT(*) as count FROM products WHERE user_id = $1',
      [req.session.userId]
    );
    
    // Policz spotkania u≈ºytkownika
    const meetingsResult = await client.query(`
      SELECT COUNT(*) as count FROM sales s 
      JOIN products p ON s.product_id = p.id 
      WHERE p.user_id = $1
    `, [req.session.userId]);
    
    // Oblicz wiek konta
    const userResult = await client.query(
      'SELECT created_at FROM users WHERE id = $1',
      [req.session.userId]
    );
    
    let accountAge = 0;
    if (userResult.rows.length > 0) {
      const createdAt = new Date(userResult.rows[0].created_at);
      const now = new Date();
      accountAge = Math.floor((now - createdAt) / (1000 * 60 * 60 * 24));
    }
    
    await client.release();
    
    res.json({
      productsCount: parseInt(productsResult.rows[0].count),
      meetingsCount: parseInt(meetingsResult.rows[0].count),
      accountAge: accountAge
    });
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania statystyk:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Serwowanie stron poszczeg√≥lnych sekcji
app.get('/produkty', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sections', 'produkty.html'));
});

app.get('/klienci', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sections', 'klienci.html'));
});

app.get('/spotkania', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sections', 'spotkania.html'));
});

app.get('/profil', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sections', 'profil.html'));
});

app.get('/sesja', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sections', 'sesja.html'));
});

// === ADMIN ENDPOINTS ===

// Route dla panelu admina
app.get('/admin', requireAuth, requireAdmin, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sections', 'admin.html'));
});

// Pobieranie wszystkich u≈ºytkownik√≥w (admin)
app.get('/api/admin/users', requireAuth, requireAdmin, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(
      'SELECT id, first_name, last_name, email, phone, created_at FROM users ORDER BY created_at DESC'
    );
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania u≈ºytkownik√≥w:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Dodawanie u≈ºytkownika (admin)
app.post('/api/admin/users', requireAuth, requireAdmin, async (req, res) => {
  const { firstName, lastName, email, phone, password } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Sprawd≈∫ czy email nie istnieje
    const emailCheck = await client.query('SELECT id FROM users WHERE email = $1', [email]);
    if (emailCheck.rows.length > 0) {
      await client.release();
      return res.status(400).json({ success: false, message: 'Ten email jest ju≈º u≈ºywany' });
    }
    
    // Zaszyfruj has≈Ço
    const passwordHash = await bcrypt.hash(password, 10);
    
    // Dodaj u≈ºytkownika
    const result = await client.query(
      'INSERT INTO users (first_name, last_name, email, phone, password_hash) VALUES ($1, $2, $3, $4, $5) RETURNING id, first_name, last_name, email, phone, created_at',
      [firstName, lastName, email, phone, passwordHash]
    );
    
    await client.release();
    res.json({ success: true, user: result.rows[0] });
  } catch (err) {
    console.error('B≈ÇƒÖd dodawania u≈ºytkownika:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Edycja u≈ºytkownika (admin)
app.put('/api/admin/users/:id', requireAuth, requireAdmin, async (req, res) => {
  const userId = req.params.id;
  const { firstName, lastName, email, phone, password } = req.body;
  
  try {
    const client = await pool.connect();
    
    // Sprawd≈∫ czy email nie jest u≈ºywany przez innego u≈ºytkownika
    const emailCheck = await client.query(
      'SELECT id FROM users WHERE email = $1 AND id != $2',
      [email, userId]
    );
    
    if (emailCheck.rows.length > 0) {
      await client.release();
      return res.status(400).json({ success: false, message: 'Ten email jest ju≈º u≈ºywany' });
    }
    
    let query, params;
    if (password) {
      // Zmie≈Ñ has≈Ço te≈º
      const passwordHash = await bcrypt.hash(password, 10);
      query = 'UPDATE users SET first_name = $1, last_name = $2, email = $3, phone = $4, password_hash = $5 WHERE id = $6 RETURNING id, first_name, last_name, email, phone';
      params = [firstName, lastName, email, phone, passwordHash, userId];
    } else {
      // Bez zmiany has≈Ça
      query = 'UPDATE users SET first_name = $1, last_name = $2, email = $3, phone = $4 WHERE id = $5 RETURNING id, first_name, last_name, email, phone';
      params = [firstName, lastName, email, phone, userId];
    }
    
    const result = await client.query(query, params);
    
    if (result.rows.length === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'U≈ºytkownik nie znaleziony' });
    }
    
    await client.release();
    res.json({ success: true, user: result.rows[0] });
  } catch (err) {
    console.error('B≈ÇƒÖd edycji u≈ºytkownika:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Usuwanie u≈ºytkownika (admin)
app.delete('/api/admin/users/:id', requireAuth, requireAdmin, async (req, res) => {
  const userId = req.params.id;
  
  // Nie pozw√≥l usunƒÖƒá siebie
  if (parseInt(userId) === req.session.userId) {
    return res.status(400).json({ success: false, message: 'Nie mo≈ºesz usunƒÖƒá swojego konta' });
  }
  
  try {
    const client = await pool.connect();
    const result = await client.query('DELETE FROM users WHERE id = $1', [userId]);
    
    if (result.rowCount === 0) {
      await client.release();
      return res.status(404).json({ success: false, message: 'U≈ºytkownik nie znaleziony' });
    }
    
    await client.release();
    res.json({ success: true, message: 'U≈ºytkownik usuniƒôty' });
  } catch (err) {
    console.error('B≈ÇƒÖd usuwania u≈ºytkownika:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Pobieranie wszystkich produkt√≥w (admin)
app.get('/api/admin/all-products', requireAuth, requireAdmin, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(`
      SELECT p.*, u.first_name || ' ' || u.last_name as owner_name 
      FROM products p 
      LEFT JOIN users u ON p.user_id = u.id 
      ORDER BY p.created_at DESC
    `);
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania produkt√≥w:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Pobieranie wszystkich klient√≥w (admin)
app.get('/api/admin/all-clients', requireAuth, requireAdmin, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query('SELECT * FROM clients ORDER BY name ASC');
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania klient√≥w:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Pobieranie wszystkich spotka≈Ñ (admin)
app.get('/api/admin/all-meetings', requireAuth, requireAdmin, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(`
      SELECT s.*, c.name as client_name, p.name as product_name, 
             u.first_name || ' ' || u.last_name as owner_name
      FROM sales s 
      JOIN clients c ON s.client_id = c.id 
      JOIN products p ON s.product_id = p.id 
      LEFT JOIN users u ON p.user_id = u.id
      ORDER BY s.meeting_datetime DESC
    `);
    await client.release();
    res.json(result.rows);
  } catch (err) {
    console.error('B≈ÇƒÖd pobierania spotka≈Ñ:', err);
    res.status(500).json({ success: false, message: 'B≈ÇƒÖd serwera' });
  }
});

// Start serwera
if (process.env.NODE_ENV !== 'production') {
  // Tryb rozwojowy - uruchom normalnie
  app.listen(PORT, async () => {
    console.log(`üöÄ Serwer aplikacji doradc√≥w handlowych dzia≈Ça na porcie ${PORT}`);
    console.log(`üåê Otw√≥rz http://localhost:${PORT} w przeglƒÖdarce`);
    
    // Test po≈ÇƒÖczenia z bazƒÖ danych Neon
    await testNeonConnection();
  });
} else {
  // Produkcja - Vercel
  console.log('üöÄ Sales Assistant App initialized for Vercel');
  testNeonConnection().catch(console.error);
}

// Export dla Vercel
module.exports = app; 